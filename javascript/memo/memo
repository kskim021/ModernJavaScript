1. 프로그래밍이란 
기계가 실행 할 수 있도록 정확하고 상세하게 요구사항을 설명하는 작업 

2. 자바스크립트 
ECMAScript 는 자바스크립트의 표준 사양을 말함.

3. Ajax
서버와 브라우저가 비동기 방식으로 데이터를 교환하는 기능 

4. JQuery
DOM 을 쉽게 제어하는 기능 

5. V8 자바스크립트 엔진
성능의 향상

6. Node.js
V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경
자바스크립트 엔진을 브라우저에서 독립시킨 실행 환경
다양한 모듈, 파일시스템, HTTP 등 빌트인(built-in, 내장) API 제공

Node.js는 비동기 I/O를 지원, 단일 스레드 이벤트 루프 기반으로 동작,
SPA(Single Page Application)에 적합 - 데이터를 실시간으로 처리함.

7. SPA 프레임워크 
Angular, React, Vue.js, Svelte 

8. 자바스크립트 특징 
웹 브라우저에서 동작하는 유일한 프로그래밍 언어 
일급 함수 : 함수가 다른 일급객체와 동일하게 다루어 지는것 
일급 객체 : 변수나 데이터에 할당 가능, 인자로 넘기기 가능, 리턴값으로 리턴가능 

* 자바스크립트나 파이썬의 함수는 일급 함수이다.

Ex) 
# 변수에 할당
const foo = function() {
   console.log("foobar");
}
// 변수를 사용해 호출
foo();

# 인자로 전달 
function sayHello() {
   return "Hello, ";
}
function greeting(helloMessage, name) {
  console.log(helloMessage() + name);
}
// `sayHello`를 `greeting` 함수에 인자로 전달
greeting(sayHello, "JavaScript!");

# 함수를 반환
function sayHello() {
   return function() {
      console.log("Hello!");
   }
}


개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어(소스코드를 바로 실행)다.

자바스크립트는 멀티 패러다임 프로그래밍 언어

9. ES6 브라우저 지원 현황
익스플러로를 제외한 대부분의 모던 브라우저는 ES6을 지원하지만 100%는 아님.
Node.js는 v4 부터 ES6를 지원
바벨(Babel)과 같은 트랜스파일러를 사용 가능


10. 자바스크립트 실행 환경
모든 브라우저에는 자바스크립트를 실행할 수 있는 자바스크립트 엔진을 내장하고 있음.
Node.js도 자바스크립트 엔진을 내장.

브라우저는 HTML, CSS, 자바스크립트를 실행하여 웹페이지를 랜더링 하고
Node.js는 브라우저 외부에서 자바스크립트 실행 환경을 제공 한다.


11. NPM 
npm은 자바스크립트 패키지 매니저 
Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할,
패키지 설치 및 관리를 위한 CLI(Command Line Interface) 제공


12. vsCode 사용
CodeRunner 라이브러리


13. 변수 (값이 저장된 메모리 공간)
변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념.
하나의 값을 저장하기 위해 메모리 공간 자체를 식별하기 위해 붙인 이름.
* CPU에서 연산, 메모리에서 저장이나 읽기(바이트 단위) 재사용 안됨
* 메모리에 저장되는 모든 값은 2진수!

변수 이름은 가독성을 높이는 부수적인 효과!


14. 식별자  (변수, 함수, 클래스 등)
값을 구별해서 식별할 수있는 고유한 이름
값은 메모리 공간에 저장됨
식별자는 값이 아니라 메모리 주소를 기억한다.


15. 변수 선언
var 전역변수
const, let 지역변수

undefined는 원시타입의 값.

선언 단계 : 변수 이름 할당
초기화 단계 : 메모리 공간을 확보하고 undefined를 할당해 초기화



16. 재할당
값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라한다.

가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여
사용하지 않는 메모리 공간을 해제하는 기능


17. 식별자 네이밍 규칙
숫자로 시작하면 안됨
명확한 네이밍 

* 일반적으로 변수나 함수는 카멜 케이스 (firstName)
생성자 함수, 클래스는 파스칼 케이스 (FirstName)


18. 리터럴
사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

표현식 :  값으로 평가될 수 있는 문이다.
문 : 프로그램을 구성하는 기본 단위이자 최소 실행 단위.
토큰 : 문법적으로 더 이상 나눌수 없는 코드의 기본 요소를 의미.

var x; (표현식이 아님)
x = 1 + 2; (표현식이면서 문임.)

표현식이 아닌 문을 실행하면 undefined를 출력한다.


19. 데이터 타입
데이터 타입은 값의 종류이며, 자바스크립트의  모든 값은 데이터 타입을 갖는다.
원시 타입 :
 숫자(number) -> 숫자 타입은 모두 실수로 처리, 
 문자열(String) -> 텍스트 데이터, 
 불리언(boolean) -> true, false, 
 undefined -> undefined 타입의 값은 undefined가 유일, 
 null -> null 타입의 값은 null이 유일, 
 심벌(symbol) -> 변경 불가능한 원시타입의 값 (오브젝트의 유일한 프로퍼티 키를 만들기 위해서 사용할 수 있다.)

객체 타입 : 객체, 함수, 배열 등

자바스크립트는 대소문자를 구분 
문자열은 일반적으로 ''(작은 따옴표) 을 사용.

템플릿 리터럴은 ``(백틱)을 사용
멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등에 사용됨
표현식을 삽입 할 때 ${}을 사용
console.log(`my name is ${name}`);

변수의 값을 빈값이라는 것을 체크 할때 undefined 보다 null 을 사용 


20. 데이터 타입의 필요성
값을 저장 시 메모리 공간의 크기를 결정하기 위해
값을 참조할 때 메모리 공간의 크기를 결정하기 위해
메모리에서 읽은 2진수를 해석하기 위해



21. 동적 타이핑
변수는 선언이 아닌 할당에 의해 타입이 결정되고, 
재할당에 타입은 동적으로 변할 수 있다.



22. 연산자
산술 -> 연산이 불가능 할경우 NaN 반환 (이항산술 (+,-,/,%) , 단항산술(++,--)), 
할당 ->  (=, +=, -=, /=, *=,%=), 
비교 -> (==, ===, !=, !==, > , <, >=, <=, 삼항연산자 ( 조건 ? true : false)), 
논리 -> (&&, ||, ! ), 
타입 -> (typeof) - null 값은 object로 반환함., 
지수 (**) 거듭제곱 - Math.pow와 같음



23. 제어문 
조건에 따라 코드를 실행하거나 반복 실행할 때 사용

블록문 : 일반적으로 제어문이나 함수를 정의할 때 사용 (함수 선언, 제어문 등)


24. 조건문 (if else, swich)
조건식의 평가 결과에 따라 블록문의 실행을 결정한다.

* 단순히 값을 결정하여 변수에 할당하는 경우에는 if else 보다 삼항연산자가 가독성에 좋다.

1. if else 는 boolean 값으로 평가 되고
2. swich는 문자열이나 숫자 값으로 평가 (swich는 break가 없으면 계속 case가 넘어감.)


25. 반복문 (for, while, do while)
조건식의 평가 결과가 참인 경우 코드 블록을 실행한다. (평가 결과가가 거짓일 때까지)

break 문은 코드 블록을 탈출하는 역할
* 조건 반복문 이외에는 SyntaxError 발생.

continue 문
반복문을 탈출하지 않고 증감식을 실행


26. 레이블 문 
프로그램의 실행순서를 제어하는 것
* 중첩 for문을 외부로 탈출 외에는 권장하지 않음.
* 프로그램의 흐름이 복잡해지고 가독성이 나빠지기 때문.


27. 타입 변환 (기존 원시값을 사용해 다른 타입의 새로운 원시 값을 생성)
- 의도적으로 값의 타입을 변환 하는 것
명시적 타입 변환
타입 캐스팅

ex) 
var x = 20; //number
var str = x.toString(); //String


- 개발자의 의도와는 상관없이 암묵적으로 타입이 자동으로 변환
암묵적 타입 변환 (재할당 X, 일회성)
타입 강제 변환 

ex) var str = x + '';

28. 단축 평가 (표현식을 평가하는 도중에 평가결과가 확정된 경우 나머지 평가결과를 생략)
|| (논리합) - 좌항에서 우항으로 평가한다. 
&&(논리곱) - 좌항에서 우항으로 평가한다.
* 논리 연산의 결과를 반영하지 않고 그대로 반환하는 것

null또는 undefined가 아닌지 확인하고 프로퍼티 참조할 때
var elem = null;
var value = elem.value; //error
-> var value = elem && elem.value;  //null

함수 매개변수에 기본값 설정 
function getStringLength(str) {
   str = str || '';
   return str.length;
}

29. null 병합 연산자 (변수에 기본값을 설정할 때 유용)
var foo = null ?? 'default'; 
console.log(foo); //default


30. 객체란 
자바스크립트를 구성하는 거의 모든것이 객체다.
원시 값을 제외한 나머지 값은 모두 객체 (함수, 배열, 정규 표현식 등)

원시 값은 변경 불가능, 객체는 변경 가능한 값
프로퍼티 : 키와 값으로 이루어짐 
프로퍼티 값이 함수이면 메소드라 한다.

프로퍼티 : 객체의 상태를 나타내는 값
메서드 : 프로퍼티를 참조하고 조작할 수 있는 동작 (객체 안에 생성한 함수)

객체는 구조화할 수 있어 유용하다.

31. 객체와 함수 
함수로 객체를 생성하기도 하고 함수 자체가 객체이기도함.


32. 객체 리터럴 (표현식)
중괄호 {}내에 0개 이상의 프로퍼티를 정의한다.


자바스크립트는 프로토타입 기반 객체 지향언어 
* 프로퍼티 키 값을 네이밍 규칙을 따르면 '' 생략 가능

* 인스턴스 : 클래스에 의해 생성되어 메모리에 저장된 실체

* 객체 존재하지 않는 프로퍼티에 접근하면 undefined를 반환.


33. 원시값과 객체의 비교 
원시타입과 객체 타입의 차이
1. 원시 값은 변경이 불가능(읽기 전용 값), 객체 타입의 값은 변경 가능
2. 원시값을 변수에 할당하면 변수에 실제 값이 저장 
   객체를 변수에 할당하면 변수에는 참조 값이 저장
3. 원시값을 다른 변수에 할당하면 원시 값이 복사되어 전달 (pass by value)
   객체를 할당한 변수를 다른 변수에 할당하면 참조 값이 복사되어 전달 (pass by reference)

* 불변성을 갖는 원시 값을 할당한 변수는 재할당 외에는 변수 값을 바꿀수 없다.


34. 함수 
일련의 과정을 문으로 구현하고 블록으로 감싸서 하나의 실행 단위로 정의한 것
즉 입력을 받아 출력을 내보내는 일련의 과정

함수는 코드의 재사용에 좋다
재사용에 좋다는 건 유지보수의 편의성과 코드의 신뢰성을 높이는 효과가 있다.

* 함수는 객체 타입의 값이다. 그러므로 이름 (식별자)을 붙일 수 있고 
  적절한 함수 이름은 코드의 가독성을 향상시킨다.


35. 함수 리터럴
숫자 리터럴, 객체 리터럴처럼 함수 리터럴로 생성할 수  있다.
함수 리터럴은 function 키워드, 함수 이름, 매개변수, 함수 코드블록으로 구성된다.


*  일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.
   함수 객체만의 고유한 프로퍼티를 갖는다.

* 함수는 함수이름을 호출하는 것이 아니라 함수 객체를 가키는 식별자를 호출한다. (함수 표현식)
  식별자가 없는 경우에는 암묵적으로 함수 이름과 동일한 이름의 식별자를 생성한다. (함수 선언문)

* 일급객체 : 함수를 값처럼 자유롭게 사용 가능

변수는 선언 
함수는 정의 
함수는 평가되면 식별자가 암묵적으로 생성되고 객체가 할당되기 때문.
   

36. 호이스팅 
함수 호이스팅

변수 호이스팅


37. Function 생성자 함수 
객체를 생성하는 함수를 말한다.

클로저를 생성하지 않고 함수선언문과 함수표현식으로 생성한 함수와 다르게 동작해서
사용하지 않는것이 좋음


38. 화살표 함수
ES6에서 도입되었고, function 키워드 대신 => 를 사욯한다. 
화살표 함수는 익명 함수로 정의한다.
const value = (a, b) => a + b;

* 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없고, arguments 객체를 생성하지 않음


39. 함수 호출
매개변수보다 인수가 부족한 경우에는 undefined로 처리되고,
더 많은 경우 초과된 인수는 무시된다.
그래서 함수를 정의할 때 인수 체크를 하는것이 좋다.

* 버려지는 것이 아닌 암묵적으로 arguments 객체의 프로퍼티로 보관된다.

* 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만드느것이 좋다.


40. 반환문 
함수는 return 키워드와 표현식으로 실행결과를 반환(return)할 수 있다.
return 키위드 뒤에 명시적으로 지정하지 않으면 undefined가 반환된다.


41. 매개변수에 값을 전달하는 방식
값에 의한 호출 (call by value)
참조에 의한 호출 (call by reference)
동작 방식은 같음.

* 객체 타입의 인수는 참조값이 복사되어 매개변수에 전달되기 때문에
수정하게되면 원본이 훼손된다.


42. 다양한 함수 형태
1. 즉시 실행 함수 : 한번만 호출 되며 다시 호출 할 수 없다.
(function(){}());

2. 재귀 함수 
함수가 자기 자신을 호출하는 방식

3. 중첩 함수 (내부 함수)
함수 내부에 정의된 함수
중첩함수를 포함한 함수는 외부 함수


4. 콜백 함수
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수


43. 순수 함수와 비순수 함수
순수함수 : 어떤 외부 상태에 의존하지 않고 변경하지도 않는 함수
비순수 함수 : 외부상태에 의존하거나 상태를 변경하는 함수 (코드의 복잡성을 높임)


44. 스코프란? 
모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수있는 유효범위가 결정된다.

* 하나의 값은 유일한 식별자에 연결되어야한다.

var 키워드는 중복 선언이 가능하다. 
let, const는 중복선언이 불가능하다.


45. 스코프 체인 
스코프가 함수의 중첩에 의해 계층적 구조를 갖는다.
변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여
상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.
(inner -> outer -> 전역)

* 상위 스코프에서 유효한 변수는 하위스코프에서 자유롭게 참조 가능하지만 
  하위 스코프에서는 유효한 변수를 상위 스코프에서 참조할 수없다.



46. 렉시컬 스코프
함수 선언의 시점에 따라 상위 스코프가 결정 된다.

* 자바스크립트는 렉시컬 스코프를 따른다.



47. 전역변수의 문제점!
변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다.
변수는 생명주기가 있다. 

지역변수의 생명주기는 함수의 생명 주기와 일치한다.

함수가 생성한 스코프는 렉시컬 환경 이라 부르는 물리적인 실체가 있다고 했다.
따라서 변수는 자신이 등록된 스코프가 소멸될 때 까지 유효하다.

메모리공간을 누군하 참조하고 있으면 해재되지 않고 확보된 상태로 남아있게 된다.

호이스팅은 스코프 단위로 동작.


전역코드는 명시적인 호출없이 실행됨.
var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.
* 암묵적 결합을 허용 하기 때문에 버그 생길 위험이 커짐.
* 생명주기가 길다.
* 전역 변수의 검색 속도가 가장 느리다.
* 네임스페이스(구분이 가능하도록 정해놓은 범위나 영역) 오염



전역 변수의 사용을 억제하는 방법 
1. 즉시 실행 함수 : 단 한번만 호출 되고 즉시 실행 함수의 지역변수가 되기 때문에.
2. 네임 스페이스 객체 : 사용하고 싶은 변수를 프로퍼티에 추가
3. 모듈 패턴 : 모듈 패턴 클래스를 모방하여 관련이 있는 변수와 함수를 모아 
               즉시실행 함수로 감싸 하나의 모듈로 만든다.
4. ES6 모듈 : ES6 모듈은 파일 자체의 독립적인 모듈 스코프를 제공.



48. let, const 키워드, 블록 레벨 스코프
* var 키워드는 중복 선언 가능함.
var 키워드로 선언한 변수는 코드 블록을 지역 스코프로 인정한다.

var 키워드로 변수를 선언하면 변수 호이스팅이 동작


let, const 키워드 : var 키워드의 단점을 보완 
1. 중복선언 X
2. 블록 레벨 스코프 
3. 변수 호이스팅 X : 선언 단계와 초기화 단계가 분리되어 진행됨.

* 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대


const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화 해야함.
* 재할당 안됨
* 상수는 재할당이 금지된 변수를 말한다.
* 프로퍼티의 동적생성, 삭제는 가능함.


변수 선언은 기본적으로 const 



16장 
49. 내부 슬롯과 내부 메서드 
의사 프로퍼티, 의사 메서드


자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 
프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.
( 프로퍼티의 상태란 프로퍼티의 값, 값의 갱신 여부, 열거 가능 여부, 재정의 가능여부 )

데이터 프로퍼티 
키와 값으로 구성된 일반적인 프로퍼티

value - 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값
writable - 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다.
enumerable  - 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다.
configurable   -  프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다.


접근자 프로퍼티 
자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 
호출되는 접근자 함수로 구성된 프로퍼티

get   - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자
set   - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자
enumerable  - 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다.
configurable   -  프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다.


프로토타입 
어떤 객체의 상위(부모) 객체의 역할을 하는 객체.
하위 객체에게 자신의 프로퍼티와 메서드를 상속한다.


프로토타입 체인 
프로토타입이 단방향 링크드 리스트 형태로 연결되어 있는 상속 구조


50. 프로퍼티 정의
새로운 프로퍼티를 추가하면서 포로퍼티 어트리뷰트를 명시적으로 정의하거나,
기존 프로퍼티의 어트리뷰트를 재정의 하는 것 ()
Object.defineProperty - 한번에 하나의 프로퍼티만 정의가능
Object.defineProperties - 여러 개의 프로퍼티 정의가능



51. 객체 변경 방지
1. 객체 확장 금지
Object.preventExtensions 메서드를 사용해 객체 확장을 금지한다.
(프로퍼티 추가가 금지)

2. 객체 밀봉 
Object.seal 메서드를 사용하고 밀봉된 객체는 읽기와 쓰기만 가능하다. 

3. 객체 동결
Object.freeze 메서드로 객체를 동결한다. 동결된 객체는 읽기만 가능한다.

4. 불변 객체 
중첩 객체는 제어가 불가능
재귀적으로 객체를 값으로 갖는 모든 프로퍼티에 메서드를 호출

* 객체는 변경 가능한 값이므로 재할당 없이 직접 변경할 수 있다.



52. 생성자 함수에 의한 객체 생성
17장 
1. Object 생성자 함수 
new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체(인스턴스)를 생성하여 반환한다.
Object 외에도 
String, Number, Boolean, Function, Array, Date, RegExp, Promise 등의 빌트인 제공

2. 생성자 함수 
프로퍼티 구조가 동일한 여러 개의 객체를 간편하게 생성 가능
new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.
- 인스턴스를 생성 (압묵적으로 빈 객체 생성)
- 생성된 인스턴스를 초기화

바인딩 : 식별자와 값을 연결


일반함수(Call)와 생성자 함수의 차이
new 를 붙인다 (내부 메서드 Construct가 호출)
this를 반환한다
new 연산자와 호출 시 객체를 생성하여 반환
new 연산자 없이 호출기 데이터 타입 반환

* this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수


내부 메서드 
내부 메서드(Call)을 갖는 함수 객체를 callable 이라 하며 (함수)
내부 메서드(Construct)를 갖는 함수 객체를 constructor (생성자 함수)
                        갖지 않는 함수 객체를 non-constructor 
                        (생성자 함수 - 호출할 수 없는 함수 : 일반 함수만 호출 )

constructor : 함수 선언문, 함수 표현식, 클래스 
non-constructor : 메서드, 화살표 함수



53. new.target (메타 프로퍼티)
생성자 함수가 new 업싱 호출되 것을 방지 하기위해 지원 (ES6)
new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가르킨다.
new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined다.

* ES6에서 도입된 최신 문법으로 IE에서는 지원하지 않는다. (스코프 세이프 생성자 패턴)



54. 함수와 일급 객체
일급객체란 
무명의 리터럴로 생성할 수 있다.
변수나 자료구조에 저장 
함수의 매개변수에 전달
함수의 반환값으로 사용




19장 프로토타입
55. 객체지향 프로그래밍 
객체의 집합으로 프로그램을 표현하는 프로그래밍 
실세계의 사고를 프로그래밍에 접목하는것 
독립적인 객체의 집합으로 프로그램을 표현

다양한 속성중에 프로그램에 필요한 속성만 간추려 표현하는것을 추상화

속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조를 객체


56. 상속과 프로토타입
상속 : 코드의 재사용으로 인해 중복 제거 

프로토타입 객체 : 객체 간 상속을 구현하기 위해 사용
모든 객체는  [[Prototype]] 내부 슬롯을 가짐
객체가 생성될 때 프로토타입이 결정되고 [[Prototype]]에 저장된다.

__proto__ 접근자 프로퍼티로 내부 슬롯에 간접적으로 접근 가능 
상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해 사용.
* 내부슬롯은 프로퍼티가 아니다.


57. 함수 객체의 prototype 프로퍼티 
함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.
(function (){}).hasOwnProperty('prototype');
* 객체를 생성하지 않는 일반 함수의 prototype 프로퍼티는 의미가 없음.

__proto__ 접근자 프로퍼티 : 모든 객체
prototype 프로퍼티 : 생성자 함수


58. 프로토타입의 constructor 프로퍼티와 생성자 함수 
모든 프로토타입은 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 prototype 프로퍼티로 
자신을 참조하고 있는 생성자 함수를 가리킨다.


59. 리터럴 표기법에 의해 생선된 객체의 생성자 함수와 프로토타입 
constructor 프로퍼티가 가리키는 생성자 함수는 인스턴스를 생성할 생성자 함수


60. 프로토타입의 생성 시점
생성자 함수가 생성되는 시점에 더불어 생성된다.

* 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.


61. 객체 생성 방식과 프로토타입의 결정 
객체 리터럴
Object 생성자 함수
생성자 함수
Object.create 메서드
클래스(ES6)

객체는 추상연산 OrdinaryObjectCreate에 의해 생성된다.
객체와 생성된 객체 사이에 연결


62. 프로토타입 체인 
자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 매커니즘
상속과 프로퍼티 검색을 위한 매커니즘

hasOwnProperty('') 메서드를 검색

* 스코프 체인은 식별자를 검색하기 위한 매커니즘


63. 오버라이딩과 프로퍼티 섀도잉
프로토타입이 소유한 프로퍼티를 프로토타입 프로퍼티, 
인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티 

오버라이딩 : 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용
오버로딩 : 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현 가능
상속관계명 에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉


하위 객체를 통해 프로토타입의 변경 또는 삭제는 불가능 
프로토타입에 직접 접근하여 변경 또는 삭제 가능


64. 프로토타입의 교체 
부모 객체인 프로토타입을 동적으로 변경할 수 있다.
프로토타입은 생성자 함수, 인스턴스에 의해 교체할 수 있다.


65. 인스턴스에 의한 프로토타입의 교체


66. instanceof 연산자
객체 instanceof 생성자 함수

생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인함


67. 직접 상속
Object.create에 의한 직접 상속
명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.
추상 연산 OrdinaryObjectCreate를 호출

__proto__ 에 의한 직접 상속
객체 리터럴 내부에서 __proto__접근자 프로퍼티를 사용


68. 정적 프로퍼티 / 메서드
정적(static) 프로퍼티/ 메서드는 생성자 함수로 
인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드이다.



69. 프로퍼티 존재 확인 
1. in 연산자
객체 내에 특정 프로퍼티가 존재하는지 여부를 확인

2. Object.prototype.hasOwnProperty 메서드



70. 프로퍼티 열거
1. for ... in 문
for(변수선언문 in 객체) {...}

프로퍼티 어트리뷰트 [[Enumerable]]의 값이 true인 프로퍼티를 열거

2. Object.key/values/entries 메서드 
객체 자신의 고유 프로퍼티만 열거하기 위해 사용





20장 strict mode 

71.
strict mode 란 
자바스크립트 언어의 문법을 좀 더 엄격히 적용
'use strict'; // 선언

*  strict mode를 전역에 적용은 하지 말것
   strict mode는 스크립트 단위로 적용 됨.
   strict mode는 함수단위로 적용하지말것 (함수를 참조하는 곳에서 문제 발생 할 수 있음)
   strict mode는 즉시 실행 함수로 감싼 스크립트 단위로 적용하는 것이 바람직함.

1. 선언하지 않은 변수를 참조하면 ReferrenceError 발생
2. delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError 발생
3. 중복된 매개변수 사용시 SyntaxError 발생
4. with문 (동일한 객체의 프로퍼티를 반복해서 사용) 사용시 SyntaxError 발생


72. 일반 함수의 this 
함수를 일반 함수로서 호출하면 this에 undefined로 바인딩 됨
생성자 함수는 할당됨


73. arguments 객체
strict mode 에서는 매개변수에 전달된 인수를 재할당 하여 변경해도
arguments 객체에 반영되지 않는다.



21장 빌트인 객체
74. 자바스크립트 객체의 분류
1. 표준 빌트인 객체 
ECMAScript 사양에 정의된 객체 
자바스크립트 실행 환경과 관계없이 언제나 사용 (전역 객체의 프로퍼티로서 제공)
40여 개의 표준 빌트인 객체를 제공한다.



2. 호스트 객체
ECMAScript 사양에 정의 되어있지 않지만 
자바스크립트 실행 환경에서 추가로 제공하는 객체



3. 사용자 정의 객체
사용자가 직접 정의한 객체


75. 원시값과 래퍼 객체

문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체



76. 전역객체
코드가 실행 전에 제일 먼저 생성되는 특수한 객체
전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.
전역 객체의 프로퍼티를 참조할 때 window를 생략 가능. (let, const는 불가)


77. 빌트인 전역 프로퍼티
전역 객체의 프로퍼티를 의미 


78. 빌트인 전역함수 
애플리케이션 전역에서 호출할 수 있는 빌트인 함수

eval 함수
자바스크립트 코드를 나타내는 문자열을 인수로 전달받는다.
기존의 스코프를 런타임에 동적으로 수정한다.

* eval 함수의 사용은 금지 (처리 속도가 느림.)


isNan :  전달받은 인수가 NaN인지 검사하여 불리언 타입으로 반환

encodeURI / decodeURI
이스케이프 처리를 위해 사용!


encodeURIComponent / decodeURIComponent
쿼리스트링 구분자 : =,?,& 까지 인코딩, 디코딩 함.



22 장 this 
79. this 키워드
자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수
this를 통해 프로퍼티나 메서드를 참조 가능 
* this 바인딩(식별자와 값을 연결하는 과정)은 함수 호출 방식에 의해 동적으로 결정

// p384

